<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aura: Particle Engine</title>
    <link rel="icon" href="https://raw.githubusercontent.com/arnetworkhouse-oss/aura/main/aura%20logo.png" type="image/png">

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020202; font-family: 'Inter', sans-serif; color: white; touch-action: none; }
        canvas { display: block; }
        .glass { background: rgba(10, 10, 10, 0.8); backdrop-filter: blur(16px); border: 1px solid rgba(255,255,255,0.1); }
        .active-btn { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.5); box-shadow: 0 0 15px rgba(255,255,255,0.1); }
        #video-container { transform: scaleX(-1); border-radius: 12px; overflow: hidden; width: 120px; height: 90px; border: 2px solid rgba(255,255,255,0.05); }
        input[type=range] { accent-color: #ffffff; cursor: pointer; height: 12px; }
        .loading-screen { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; z-index: 100; transition: opacity 0.8s; }
        .label-text { font-size: 10px; text-transform: uppercase; letter-spacing: 0.1em; opacity: 0.6; margin-bottom: 4px; display: flex; justify-content: space-between; }
        
        #controls-panel { transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        @media (max-width: 768px) {
            #controls-panel { transform: translateX(-100%); position: fixed; top: 0; left: 0; height: 100%; width: 85%; max-width: 320px; z-index: 50; overflow-y: auto; }
            #controls-panel.open { transform: translateX(0); box-shadow: 0 0 0 100vmax rgba(0,0,0,0.5); }
        }
            .global-footer {
                position: fixed;
                text-align: center;
                bottom: 12px;
            left: 50%;  
            transform: translateX(-50%);
            z-index: 40;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 999px;
}

    </style>
</head>
<body>

<div id="loading" class="loading-screen">
    <div class="text-center p-6">
        <h1 class="text-4xl font-extralight tracking-[0.3em] mb-4">AURA</h1>
        <div class="w-48 h-[1px] bg-white/20 mx-auto relative overflow-hidden">
            <div class="absolute inset-0 bg-white animate-[slide_2s_infinite]"></div>
        </div>
        <p class="mt-6 text-[10px] tracking-widest text-gray-500 uppercase">Optimizing for Mobile GPU</p>
        <p class="mt-6 text-[10px] tracking-widest text-gray-500 uppercase">Made By AR Network House</p>
    </div>
</div>

<style> @keyframes slide { from { transform: translateX(-100%); } to { transform: translateX(100%); } } </style>

<button id="menu-toggle" class="fixed top-6 left-6 z-[60] glass p-3 rounded-full md:hidden">
    <div id="hamburger-icon" class="w-6 h-4 flex flex-col justify-between">
        <span class="block h-[1px] w-full bg-white transition-all"></span>
        <span class="block h-[1px] w-full bg-white transition-all"></span>
        <span class="block h-[1px] w-full bg-white transition-all"></span>
    </div>
</button>

<div class="fixed top-6 right-6 z-20">
    <div id="video-container" class="glass shadow-2xl relative">
        <video id="input_video" class="w-full h-full object-cover hidden" playsinline></video>
        <canvas id="gesture_canvas" class="w-full h-full object-cover"></canvas>
        <div id="gesture-indicator" class="absolute bottom-1 left-2 text-[8px] font-bold uppercase tracking-wider text-white/50">Cam Off</div>
    </div>
</div>

<div id="controls-panel" class="glass p-8 md:rounded-[2rem] flex flex-col gap-6 shadow-2xl border-white/5 md:fixed md:left-8 md:top-1/2 md:-translate-y-1/2 md:w-72">
    <div class="flex flex-col gap-6 mt-12 md:mt-0">
        <section>
            <h2 class="label-text">Select Geometry</h2>
            <div class="grid grid-cols-3 gap-2" id="shape-selector">
                <button onclick="setShape('heart')" class="glass py-2 rounded-xl text-[10px] active-btn" data-shape="heart">Heart</button>
                <button onclick="setShape('saturn')" class="glass py-2 rounded-xl text-[10px]" data-shape="saturn">Saturn</button>
                <button onclick="setShape('buddha')" class="glass py-2 rounded-xl text-[10px]" data-shape="buddha">Buddha</button>
                <button onclick="setShape('flower')" class="glass py-2 rounded-xl text-[10px]" data-shape="flower">Flower</button>
                <button onclick="setShape('sphere')" class="glass py-2 rounded-xl text-[10px]" data-shape="sphere">Sphere</button>
                <button onclick="setShape('burst')" class="glass py-2 rounded-xl text-[10px]" data-shape="burst">Burst</button>
            </div>
        </section>

        <section class="flex flex-col gap-4">
            <h2 class="label-text">Dynamics</h2>
            <div class="flex items-center justify-between">
                <span class="text-xs font-medium">Gesture Control</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="tilt-toggle" checked class="sr-only peer">
                    <div class="w-10 h-5 bg-gray-800 rounded-full peer peer-checked:bg-indigo-500 after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:after:translate-x-5"></div>
                </label>
            </div>
            <div>
                <label class="label-text">Manual Speed <span id="rotate-val">1.0</span></label>
                <input type="range" id="rotate-slider" min="0" max="5" step="0.1" value="1.0" class="w-full bg-white/10 rounded-lg appearance-none">
            </div>
        </section>

        <section class="flex flex-col gap-4">
            <h2 class="label-text">Visuals</h2>
            <div>
                <label class="label-text">Color Hue <span id="hue-val">260</span></label>
                <input type="range" id="hue-slider" min="0" max="360" value="260" class="w-full bg-white/10 rounded-lg appearance-none">
            </div>
            <div>
                <label class="label-text">Particle Size <span id="size-val">2.5</span></label>
                <input type="range" id="size-slider" min="0.5" max="10.0" step="0.1" value="2.5" class="w-full bg-white/10 rounded-lg appearance-none">
            </div>
        </section>
        
        <button onclick="captureScreenshot()" class="mt-2 bg-white text-black font-bold py-4 rounded-2xl text-[10px] tracking-widest active:scale-95 transition-transform">CAPTURE SNAPSHOT</button>
    </div>

    <div class="glass p-5 rounded-3xl mt-4">
        <h3 class="label-text mb-2">Mobile Interaction</h3>
        <p class="text-[10px] leading-relaxed text-gray-400">
            • <b class="text-white">Drag:</b> Rotate Aura<br>
            • <b class="text-white">Pinch:</b> (Camera Only) Rotate Z<br>
            • <b class="text-white">Sensors:</b> Tilt device to shift light
        </p>
    </div>
    
</div>


<script id="vertexShader" type="x-shader/x-vertex">
    uniform float uTime;
    uniform float uTransition;
    uniform float uScale;
    uniform float uSpread;
    uniform float uNoise;
    uniform float uPointSize;
    attribute vec3 targetPosition;
    attribute vec3 color;
    varying vec3 vColor;
    
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    
    float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        vec4 j = p - 49.0 * floor(p * 0.02040816);
        vec4 x_ = floor(j * 0.14285714);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ * 0.14285714 + 0.07142857;
        vec4 y = y_ * 0.14285714 + 0.07142857;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        return 42.0 * dot(m*m*m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }
    
    void main() {
        vColor = color;
        vec3 pos = mix(position, targetPosition, uTransition);
        pos *= (uSpread * uScale);
        float n = snoise(vec3(pos.x * 0.1, pos.y * 0.1, uTime * 0.3));
        pos += n * uNoise;
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_PointSize = uPointSize * (350.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    varying vec3 vColor;
    void main() {
        float d = distance(gl_PointCoord, vec2(0.5));
        if (d > 0.5) discard;
        float g = pow(1.0 - (d * 2.0), 1.8);
        gl_FragColor = vec4(vColor, g);
    }
</script>

<script>
/** * GLOBALS & MOBILE ADAPTATION */
const PARTICLE_COUNT = 15000;
let scene, camera, renderer, particles, material;
let video, hands, cameraUtils;

let state = {
    shape: 'heart', hue: 260, size: 2.5, noise: 1.2, transition: 1.0,
    spread: 1.0, scale: 1.0,
    targetRot: { x: 0, y: 0, z: 0 },
    orbitSpeed: 0.002, useTilt: true, isPinching: false
};

const shapes = {};

// Mobile Menu Auto-Collapse
const menuToggle = document.getElementById('menu-toggle');
const panel = document.getElementById('controls-panel');
menuToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    panel.classList.toggle('open');
});

document.addEventListener('click', (e) => {
    if (panel.classList.contains('open') && !panel.contains(e.target) && !menuToggle.contains(e.target)) {
        panel.classList.remove('open');
    }
});

function createGeometries() {
    const data = { heart: new Float32Array(PARTICLE_COUNT * 3), saturn: new Float32Array(PARTICLE_COUNT * 3), buddha: new Float32Array(PARTICLE_COUNT * 3), flower: new Float32Array(PARTICLE_COUNT * 3), sphere: new Float32Array(PARTICLE_COUNT * 3), burst: new Float32Array(PARTICLE_COUNT * 3) };
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const t = Math.random() * Math.PI * 2;
        data.heart[i3] = 16 * Math.pow(Math.sin(t), 3);
        data.heart[i3+1] = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        data.heart[i3+2] = (Math.random() - 0.5) * 6;

        const u = Math.random(), v = Math.random(), th = 2 * Math.PI * u, ph = Math.acos(2 * v - 1);
        data.sphere[i3] = 15 * Math.sin(ph) * Math.cos(th);
        data.sphere[i3+1] = 15 * Math.sin(ph) * Math.sin(th);
        data.sphere[i3+2] = 15 * Math.cos(ph);

        const r = 16 + Math.random() * 6, a = Math.random() * Math.PI * 2;
        data.saturn[i3] = (i < PARTICLE_COUNT * 0.5) ? 10 * Math.sin(ph) * Math.cos(th) : r * Math.cos(a);
        data.saturn[i3+1] = (i < PARTICLE_COUNT * 0.5) ? 10 * Math.sin(ph) * Math.sin(th) : (Math.random() - 0.5) * 1.5;
        data.saturn[i3+2] = (i < PARTICLE_COUNT * 0.5) ? 10 * Math.cos(ph) : r * Math.sin(a);

        const by = (Math.random() - 0.5) * 25, bRad = (12 - Math.abs(by)) * (0.4 + Math.sin(by * 0.2 + 1.2) * 0.6), bA = Math.random() * Math.PI * 2;
        data.buddha[i3] = bRad * Math.cos(bA); data.buddha[i3+1] = by - 5; data.buddha[i3+2] = bRad * Math.sin(bA) * 0.7;

        const p = Math.random() * Math.PI * 2, fth = Math.random() * Math.PI * 2, fr = 15 * Math.cos(5 * p);
        data.flower[i3] = fr * Math.cos(p) * Math.sin(fth); data.flower[i3+1] = fr * Math.sin(p) * Math.sin(fth); data.flower[i3+2] = fr * Math.cos(fth) * 0.3;

        const br = Math.random() * 30, bt = Math.random() * Math.PI * 2, bp = Math.random() * Math.PI;
        data.burst[i3] = br * Math.sin(bp) * Math.cos(bt); data.burst[i3+1] = br * Math.sin(bp) * Math.sin(bt); data.burst[i3+2] = br * Math.cos(bp);
    }
    return data;
}

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 60;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const geoData = createGeometries();
    Object.assign(shapes, geoData);

    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const colAttr = new Float32Array(PARTICLE_COUNT * 3);
    
    // FILL INITIAL POSITION SO IT'S NOT EMPTY
    pos.set(shapes['heart']);

    const baseColor = new THREE.Color(`hsl(${state.hue}, 70%, 60%)`);
    for(let i=0; i<PARTICLE_COUNT; i++) { colAttr[i*3] = baseColor.r; colAttr[i*3+1] = baseColor.g; colAttr[i*3+2] = baseColor.b; }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('targetPosition', new THREE.BufferAttribute(new Float32Array(shapes['heart']), 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colAttr, 3));

    material = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uTransition: { value: 1.0 }, uScale: { value: 1.0 }, uSpread: { value: 1.0 }, uNoise: { value: 1.2 }, uPointSize: { value: 2.5 } },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    initTracking();
}

// FIXED: SETSHAPE NOW TRIGGERS MORPH EVERY TIME
function setShape(type) {
    // Save current target to the base position attribute for smooth mix
    const posAttr = particles.geometry.getAttribute('position');
    const targetAttr = particles.geometry.getAttribute('targetPosition');
    posAttr.array.set(targetAttr.array);
    posAttr.needsUpdate = true;

    // Load new target shape
    targetAttr.array.set(shapes[type]);
    targetAttr.needsUpdate = true;

    state.shape = type;
    state.transition = 0.0;
    material.uniforms.uTransition.value = 0.0;

    document.querySelectorAll('#shape-selector button').forEach(b => b.classList.toggle('active-btn', b.dataset.shape === type));
    if(window.innerWidth < 768) panel.classList.remove('open');
}

function initTracking() {
    video = document.getElementById('input_video');
    hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

    hands.onResults((res) => {
        const indicator = document.getElementById('gesture-indicator');
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const hand = res.multiHandLandmarks[0];
            const thumb = hand[4], index = hand[8];
            const pDist = Math.hypot(index.x - thumb.x, index.y - thumb.y);
            
            if (pDist < 0.07) {
                state.isPinching = true;
                indicator.innerHTML = "<span class='text-indigo-400'>PINCH</span>";
            } else {
                state.isPinching = false;
                indicator.innerText = "Tracking";
            }

            if (state.useTilt) {
                state.targetRot.y = (hand[9].x - 0.5) * 1.5;
                state.targetRot.x = (hand[9].y - 0.5) * 1.5;
            }
            state.spread = THREE.MathUtils.mapLinear(pDist, 0.05, 0.3, 0.8, 2.0);
        } else {
            indicator.innerText = "No Hand";
            state.isPinching = false;
        }
    });

    cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: 180, height: 135
    });
    
    cameraUtils.start().then(() => {
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => document.getElementById('loading').remove(), 800);
    }).catch(() => {
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => document.getElementById('loading').remove(), 800);
    });
}

document.getElementById('hue-slider').addEventListener('input', (e) => {
    state.hue = e.target.value;
    document.getElementById('hue-val').innerText = state.hue;
    const colAttr = particles.geometry.getAttribute('color');
    const c = new THREE.Color(`hsl(${state.hue}, 70%, 60%)`);
    for(let i=0; i<PARTICLE_COUNT; i++) { colAttr.array[i*3]=c.r; colAttr.array[i*3+1]=c.g; colAttr.array[i*3+2]=c.b; }
    colAttr.needsUpdate = true;
});

document.getElementById('size-slider').addEventListener('input', (e) => {
    state.size = parseFloat(e.target.value);
    document.getElementById('size-val').innerText = state.size.toFixed(1);
});

document.getElementById('rotate-slider').addEventListener('input', (e) => {
    state.orbitSpeed = parseFloat(e.target.value) * 0.002;
    document.getElementById('rotate-val').innerText = e.target.value;
});

document.getElementById('tilt-toggle').addEventListener('change', (e) => state.useTilt = e.target.checked);

function captureScreenshot() {
    renderer.render(scene, camera);
    const link = document.createElement('a');
    link.download = 'aura-mobile.png';
    link.href = renderer.domElement.toDataURL('image/png');
    link.click();
}

function animate(time) {
    requestAnimationFrame(animate);
    material.uniforms.uTime.value = time * 0.001;
    
    // SMOOTH TRANSITION PROGRESSION
    if (state.transition < 1.0) {
        state.transition = Math.min(1.0, state.transition + 0.02);
        material.uniforms.uTransition.value = state.transition;
    }

    material.uniforms.uSpread.value = THREE.MathUtils.lerp(material.uniforms.uSpread.value, state.spread, 0.1);
    material.uniforms.uPointSize.value = state.size + (state.isPinching ? 1.5 : 0);

    if (state.useTilt) {
        particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, state.targetRot.x, 0.05);
        particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, state.targetRot.y, 0.05);
    } else {
        particles.rotation.y += state.orbitSpeed;
    }
    renderer.render(scene, camera);
}

init();
animate();
</script>
<footer class="global-footer">
  <p>
    Game maintained by 
    <a href="https://arnetworkhouse.in/" target="_blank">AR NETWORK HOUSE</a>
  </p>
  <p>
    | <a href="https://arnetworkhouse-oss.github.io/ar-network-house/more.html" target="_blank">MORE GAMES</a> |
    <a href="https://arnetworkhouse-oss.github.io/ar-network-house/feedback_game.html" target="_blank">RATE US</a> |
  </p>
</footer>
</body>
</html>
