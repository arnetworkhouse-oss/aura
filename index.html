<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aura: Particle Engine</title>
    <link rel="icon" href="https://raw.githubusercontent.com/arnetworkhouse-oss/aura/main/aura%20logo.png"
        type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }
        .glass { background: rgba(10, 10, 10, 0.85); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.1); }
        .active-btn { background: rgba(99, 102, 241, 0.4); border-color: rgba(129, 140, 248, 0.6); box-shadow: 0 0 20px rgba(99, 102, 241, 0.3); }
        
        /* Responsive Layout */
        #control-panel { transition: transform 0.4s ease, opacity 0.3s; }
        @media (max-width: 768px) {
            #control-panel { position: fixed; left: 1rem; right: 1rem; top: 5rem; width: auto; transform: translateY(-20px); opacity: 0; pointer-events: none; }
            #control-panel.open { transform: translateY(0); opacity: 1; pointer-events: auto; }
            #project-logo { width: 80px; top: 20px; left: 20px; }
        }

        #video-container { transform: scaleX(-1); border-radius: 12px; overflow: hidden; width: 150px; height: 110px; border: 2px solid rgba(255,255,255,0.1); }
        input[type=range] { accent-color: #6366f1; cursor: pointer; height: 4px; border-radius: 2px; }
        .label-text { font-size: 11px; text-transform: uppercase; letter-spacing: 0.15em; opacity: 0.6; margin-bottom: 6px; display: flex; justify-content: space-between; }
        
        #project-logo { position: fixed; top: 32px; left: 32px; width: 120px; z-index: 30; pointer-events: none; }
    </style>
</head>
<body>


    

<button id="menu-toggle" class="fixed top-6 right-6 z-50 p-4 glass rounded-2xl md:hidden">
    <svg id="menu-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" />
    </svg>
</button>

<div class="fixed bottom-8 right-8 z-20 md:top-8 md:bottom-auto">
    <div id="video-container" class="glass shadow-2xl relative">
        <video id="input_video" class="hidden"></video>
        <canvas id="gesture_canvas" class="w-full h-full object-cover"></canvas>
        <div id="gesture-indicator" class="absolute bottom-2 left-3 text-[9px] font-bold uppercase tracking-wider text-indigo-400">Loading Tracker...</div>
    </div>
</div>

<div id="control-panel" class="z-40 flex flex-col gap-4 md:fixed md:left-8 md:top-1/2 md:-translate-y-1/2 md:w-80">
    <div class="glass p-8 rounded-[2.5rem] flex flex-col gap-6 shadow-2xl border-white/5">
        <section>
            <h2 class="label-text">Morph Shape</h2>
            <div class="grid grid-cols-2 gap-2" id="shape-selector">
                <button onclick="setShape('heart')" class="glass py-3 rounded-xl text-xs active-btn" data-shape="heart">Heart</button>
                <button onclick="setShape('saturn')" class="glass py-3 rounded-xl text-xs" data-shape="saturn">Saturn</button>
                <button onclick="setShape('buddha')" class="glass py-3 rounded-xl text-xs" data-shape="buddha">Buddha</button>
                <button onclick="setShape('flower')" class="glass py-3 rounded-xl text-xs" data-shape="flower">Flower</button>
                <button onclick="setShape('sphere')" class="glass py-3 rounded-xl text-xs" data-shape="sphere">Sphere</button>
                <button onclick="setShape('burst')" class="glass py-3 rounded-xl text-xs" data-shape="burst">Burst</button>
            </div>
        </section>

        <section class="flex flex-col gap-5">
            <h2 class="label-text">Visibility Controls</h2>
            <div>
                <label class="label-text">Global Scale <span id="scale-val">1.5</span></label>
                <input type="range" id="scale-slider" min="0.5" max="4.0" step="0.1" value="1.5" class="w-full appearance-none bg-white/10">
            </div>
            <div>
                <label class="label-text">Particle Thickness <span id="size-val">4.0</span></label>
                <input type="range" id="size-slider" min="1.0" max="15.0" step="0.5" value="4.0" class="w-full appearance-none bg-white/10">
            </div>
        </section>

        <section class="flex flex-col gap-4">
            <h2 class="label-text">Dynamics</h2>
            <div>
                <label class="label-text">Auto-Rotate Speed</label>
                <input type="range" id="rotate-slider" min="0" max="5" step="0.1" value="1.0" class="w-full appearance-none bg-white/10">
            </div>
        </section>
        
        <button onclick="captureScreenshot()" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 rounded-2xl text-[10px] tracking-widest transition-all">SAVE IMAGE</button>
    </div>
</div>

<script id="vertexShader" type="x-shader/x-vertex">
    uniform float uTime;
    uniform float uTransition;
    uniform float uScale;
    uniform float uPointSize;
    attribute vec3 targetPosition;
    attribute vec3 color;
    varying vec3 vColor;

    void main() {
        vColor = color;
        // The core morphing math
        vec3 pos = mix(position, targetPosition, uTransition);
        
        // uScale now influences the base geometry size significantly
        pos *= uScale;
        
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        
        // Enhanced point size math for better visibility
        gl_PointSize = uPointSize * (400.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    varying vec3 vColor;
    void main() {
        float d = distance(gl_PointCoord, vec2(0.5));
        if (d > 0.5) discard;
        // Sharper glow for better visibility
        float strength = pow(1.0 - (d * 2.0), 1.5);
        gl_FragColor = vec4(vColor, strength);
    }
</script>

<script>
/** * ENGINE STATE
 */
const PARTICLE_COUNT = 16000;
let scene, camera, renderer, particles, material;
let video, hands, cameraUtils;

let state = {
    shape: 'heart',
    hue: 240,
    size: 4.0,
    baseScale: 1.5, // Manually adjusted via slider
    gestureScale: 1.0, // Multiplied by hand distance
    transition: 1.0,
    zDepth: 40,
    targetRot: { x: 0, y: 0, z: 0 },
    orbitSpeed: 0.002
};

const shapes = {};

/** * SHAPE DEFINITIONS (Increased Base Coordinates)
 */
function generateGeometries() {
    const data = { heart: new Float32Array(PARTICLE_COUNT * 3), saturn: new Float32Array(PARTICLE_COUNT * 3), buddha: new Float32Array(PARTICLE_COUNT * 3), flower: new Float32Array(PARTICLE_COUNT * 3), sphere: new Float32Array(PARTICLE_COUNT * 3), burst: new Float32Array(PARTICLE_COUNT * 3) };
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const t = Math.random() * Math.PI * 2;

        // Enlarged Heart
        const ht = Math.random() * Math.PI * 2;
        data.heart[i3] = 18 * Math.pow(Math.sin(ht), 3);
        data.heart[i3+1] = 15 * Math.cos(ht) - 6 * Math.cos(2*ht) - 3 * Math.cos(3*ht) - Math.cos(4*ht);
        data.heart[i3+2] = (Math.random() - 0.5) * 8;

        // Enlarged Saturn
        const sr = (i < PARTICLE_COUNT * 0.5) ? 12 : 20 + Math.random() * 8;
        const sa = Math.random() * Math.PI * 2;
        data.saturn[i3] = sr * Math.cos(sa);
        data.saturn[i3+1] = (i < PARTICLE_COUNT * 0.5) ? (Math.random()-0.5)*20 : (Math.random()-0.5)*2;
        data.saturn[i3+2] = sr * Math.sin(sa);

        // Buddha Silhouette
        const by = (Math.random() - 0.5) * 35;
        const br = (15 - Math.abs(by*0.4)) * (0.4 + Math.sin(by * 0.15 + 1) * 0.6);
        data.buddha[i3] = br * Math.cos(t);
        data.buddha[i3+1] = by - 5;
        data.buddha[i3+2] = br * Math.sin(t) * 0.8;

        // Large Flower
        const fp = Math.random() * Math.PI * 2, fth = Math.random() * Math.PI * 2;
        const fr = 20 * Math.cos(6 * fp);
        data.flower[i3] = fr * Math.cos(fp) * Math.sin(fth);
        data.flower[i3+1] = fr * Math.sin(fp) * Math.sin(fth);
        data.flower[i3+2] = fr * Math.cos(fth) * 0.4;

        // Large Sphere
        const u = Math.random(), v = Math.random();
        const sphi = Math.acos(2 * v - 1), stheta = 2 * Math.PI * u;
        data.sphere[i3] = 20 * Math.sin(sphi) * Math.cos(stheta);
        data.sphere[i3+1] = 20 * Math.sin(sphi) * Math.sin(stheta);
        data.sphere[i3+2] = 20 * Math.cos(sphi);

        // Huge Burst
        const br_r = Math.random() * 45;
        data.burst[i3] = br_r * Math.sin(sphi) * Math.cos(stheta);
        data.burst[i3+1] = br_r * Math.sin(sphi) * Math.sin(stheta);
        data.burst[i3+2] = br_r * Math.cos(sphi);
    }
    return data;
}

/** * INITIALIZATION
 */
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 45;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    Object.assign(shapes, generateGeometries());
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT * 3), 3));
    geometry.setAttribute('targetPosition', new THREE.BufferAttribute(shapes[state.shape], 3));
    
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const c = new THREE.Color('#6366f1');
    for(let i=0; i<PARTICLE_COUNT; i++) { colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b; }
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    material = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uTransition: { value: 0 }, uScale: { value: 1.5 }, uPointSize: { value: 4.0 } },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    initTracking();
}

function initTracking() {
    video = document.getElementById('input_video');
    const indicator = document.getElementById('gesture-indicator');

    hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
    
    hands.onResults((res) => {
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const hand = res.multiHandLandmarks[0];
            const thumb = hand[4], index = hand[8];
            
            // Multiplier for larger visual scale based on finger spread
            const spread = Math.hypot(index.x - thumb.x, index.y - thumb.y);
            state.gestureScale = THREE.MathUtils.mapLinear(spread, 0.05, 0.4, 0.8, 2.5);
            
            // Rotation Tracking
            state.targetRot.z = Math.atan2(index.y - thumb.y, index.x - thumb.x) + Math.PI/2;
            state.targetRot.y = (hand[9].x - 0.5) * 2.0;
            state.targetRot.x = (hand[9].y - 0.5) * 2.0;
            
            indicator.innerText = "Hand Active";
        } else {
            indicator.innerText = "Searching...";
        }
    });

    cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({ image: video }); }, width: 150, height: 110 });
    cameraUtils.start();
}

/** * UI INTERACTIVITY
 */
function setShape(type) {
    state.shape = type;
    particles.geometry.getAttribute('targetPosition').array.set(shapes[type]);
    particles.geometry.getAttribute('targetPosition').needsUpdate = true;
    state.transition = 0;
    document.querySelectorAll('#shape-selector button').forEach(b => b.classList.toggle('active-btn', b.dataset.shape === type));
}

document.getElementById('scale-slider').addEventListener('input', (e) => {
    state.baseScale = parseFloat(e.target.value);
    document.getElementById('scale-val').innerText = state.baseScale.toFixed(1);
});

document.getElementById('size-slider').addEventListener('input', (e) => {
    state.size = parseFloat(e.target.value);
    document.getElementById('size-val').innerText = state.size.toFixed(1);
});

document.getElementById('rotate-slider').addEventListener('input', (e) => state.orbitSpeed = parseFloat(e.target.value) * 0.002);

// Hamburger menu toggle
document.getElementById('menu-toggle').addEventListener('click', () => {
    document.getElementById('control-panel').classList.toggle('open');
});

function animate(time) {
    requestAnimationFrame(animate);
    material.uniforms.uTime.value = time * 0.001;
    
    if (state.transition < 1.0) state.transition += 0.02;
    material.uniforms.uTransition.value = state.transition;
    
    // Combine Manual Scale and Gesture Scale
    const finalScale = state.baseScale * state.gestureScale;
    material.uniforms.uScale.value = THREE.MathUtils.lerp(material.uniforms.uScale.value, finalScale, 0.1);
    material.uniforms.uPointSize.value = state.size;

    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, state.targetRot.x, 0.05);
    particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, state.targetRot.y + (time * state.orbitSpeed), 0.05);
    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, state.targetRot.z, 0.05);

    renderer.render(scene, camera);
}

init();
animate();

function captureScreenshot() {
    renderer.render(scene, camera);
    const link = document.createElement('a');
    link.download = 'aura-vision.png';
    link.href = renderer.domElement.toDataURL('image/png');
    link.click();
}
</script>
</body>
</html>
