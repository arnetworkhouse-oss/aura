<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aura: Particle Engine</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020202; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }
        .glass { background: rgba(10, 10, 10, 0.8); backdrop-filter: blur(16px); border: 1px solid rgba(255,255,255,0.1); }
        .active-btn { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.5); box-shadow: 0 0 15px rgba(255,255,255,0.1); }
        #video-container { transform: scaleX(-1); border-radius: 12px; overflow: hidden; width: 180px; height: 135px; border: 2px solid rgba(255,255,255,0.05); }
        input[type=range] { accent-color: #ffffff; cursor: pointer; }
        .loading-screen { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; z-index: 100; transition: opacity 0.8s; }
        .label-text { font-size: 10px; text-transform: uppercase; letter-spacing: 0.1em; opacity: 0.6; margin-bottom: 4px; display: flex; justify-content: space-between; }
    </style>
</head>
<body>

<div id="loading" class="loading-screen">
    <div class="text-center">
        <h1 class="text-4xl font-extralight tracking-[0.3em] mb-4">AURA</h1>
        <div class="w-48 h-[1px] bg-white/20 mx-auto relative overflow-hidden">
            <div class="absolute inset-0 bg-white animate-[slide_2s_infinite]"></div>
        </div>
        <p class="mt-6 text-[10px] tracking-widest text-gray-500 uppercase">Waking GPU & Neural Hand-Tracking</p>
    </div>
</div>

<style> @keyframes slide { from { transform: translateX(-100%); } to { transform: translateX(100%); } } </style>

<div class="fixed top-8 right-8 z-20">
    <div id="video-container" class="glass shadow-2xl relative">
        <video id="input_video" class="w-full h-full object-cover hidden"></video>
        <canvas id="gesture_canvas" class="w-full h-full object-cover"></canvas>
        <div id="gesture-indicator" class="absolute bottom-2 left-3 text-[9px] font-bold uppercase tracking-wider text-white/50">Initializing...</div>
    </div>
</div>

<div class="fixed left-8 top-1/2 -translate-y-1/2 z-20 flex flex-col gap-4 w-72">
    <div class="glass p-8 rounded-[2rem] flex flex-col gap-6 shadow-2xl border-white/5">
        <section>
            <h2 class="label-text">Select Geometry</h2>
            <div class="grid grid-cols-3 gap-2" id="shape-selector">
                <button onclick="setShape('heart')" class="glass py-2 rounded-xl text-[10px] hover:bg-white/10 transition active-btn" data-shape="heart">Heart</button>
                <button onclick="setShape('saturn')" class="glass py-2 rounded-xl text-[10px] hover:bg-white/10 transition" data-shape="saturn">Saturn</button>
                <button onclick="setShape('buddha')" class="glass py-2 rounded-xl text-[10px] hover:bg-white/10 transition" data-shape="buddha">Buddha</button>
                <button onclick="setShape('flower')" class="glass py-2 rounded-xl text-[10px] hover:bg-white/10 transition" data-shape="flower">Flower</button>
                <button onclick="setShape('sphere')" class="glass py-2 rounded-xl text-[10px] hover:bg-white/10 transition" data-shape="sphere">Sphere</button>
                <button onclick="setShape('burst')" class="glass py-2 rounded-xl text-[10px] hover:bg-white/10 transition" data-shape="burst">Burst</button>
            </div>
        </section>

        <section class="flex flex-col gap-4">
            <h2 class="label-text">Hand Dynamics</h2>
            <div class="flex items-center justify-between">
                <span class="text-xs font-medium">Pinch-to-Rotate</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="tilt-toggle" checked class="sr-only peer">
                    <div class="w-10 h-5 bg-gray-800 rounded-full peer peer-checked:bg-indigo-500 after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:after:translate-x-5"></div>
                </label>
            </div>
            <div>
                <label class="label-text">Manual Orbit Speed <span id="rotate-val">1.0</span></label>
                <input type="range" id="rotate-slider" min="0" max="5" step="0.1" value="1.0" class="w-full h-[2px] bg-white/10 rounded-lg appearance-none">
            </div>
        </section>

        <section class="flex flex-col gap-4">
            <h2 class="label-text">Visual Style</h2>
            <div>
                <label class="label-text">Color Hue <span id="hue-val">260</span></label>
                <input type="range" id="hue-slider" min="0" max="360" value="260" class="w-full h-[2px] bg-white/10 rounded-lg appearance-none">
            </div>
            <div>
                <label class="label-text">Particle Size <span id="size-val">2.5</span></label>
                <input type="range" id="size-slider" min="0.5" max="10.0" step="0.1" value="2.5" class="w-full h-[2px] bg-white/10 rounded-lg appearance-none">
            </div>
        </section>
        
        <button onclick="captureScreenshot()" class="mt-2 bg-white text-black font-bold py-4 rounded-2xl text-[10px] tracking-widest hover:scale-[1.02] transition-transform active:scale-[0.98]">CAPTURE SNAPSHOT</button>
    </div>

    <div class="glass p-5 rounded-3xl opacity-40 hover:opacity-100 transition-opacity">
        <h3 class="label-text mb-2">Gesture Guide</h3>
        <p class="text-[10px] leading-relaxed text-gray-300">
            • <b class="text-white">Pinch:</b> Thumb + Index to rotate Z-axis<br>
            • <b class="text-white">Palm:</b> Move hand to tilt X/Y axes<br>
            • <b class="text-white">Depth:</b> Move hand closer/further to zoom<br>
            • <b class="text-white">Expansion:</b> Open/Close fingers to scale
        </p>
    </div>
</div>

<script id="vertexShader" type="x-shader/x-vertex">
    uniform float uTime;
    uniform float uTransition;
    uniform float uScale;
    uniform float uSpread;
    uniform float uNoise;
    uniform float uPointSize;
    
    attribute vec3 targetPosition;
    attribute vec3 color;
    
    varying vec3 vColor;

    // Simplex noise logic for organic flow
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        vec4 j = p - 49.0 * floor(p * 0.02040816);
        vec4 x_ = floor(j * 0.14285714);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ * 0.14285714 + 0.07142857;
        vec4 y = y_ * 0.14285714 + 0.07142857;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        return 42.0 * dot(m*m*m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }

    void main() {
        vColor = color;
        vec3 pos = mix(position, targetPosition, uTransition);
        pos *= (uSpread * uScale);
        
        float n = snoise(vec3(pos.x * 0.1, pos.y * 0.1, uTime * 0.3));
        pos += n * uNoise;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_PointSize = uPointSize * (350.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    varying vec3 vColor;
    void main() {
        float d = distance(gl_PointCoord, vec2(0.5));
        if (d > 0.5) discard;
        float g = pow(1.0 - (d * 2.0), 1.8);
        gl_FragColor = vec4(vColor, g);
    }
</script>

<script>
/** * GLOBALS & CONFIG
 */
const PARTICLE_COUNT = 18000;
let scene, camera, renderer, particles, material;
let video, hands, cameraUtils, canvasCtx;

let state = {
    shape: 'heart',
    hue: 260,
    size: 2.5,
    noise: 1.2,
    transition: 1.0,
    // Gesture States
    spread: 1.0,
    scale: 1.0,
    zDepth: 50,
    targetRot: { x: 0, y: 0, z: 0 },
    orbitSpeed: 0.002,
    useTilt: true,
    isPinching: false
};

const shapes = {};

/**
 * MATH: PROCEDURAL SHAPES
 */
function createGeometries() {
    const data = { 
        heart: new Float32Array(PARTICLE_COUNT * 3),
        saturn: new Float32Array(PARTICLE_COUNT * 3),
        buddha: new Float32Array(PARTICLE_COUNT * 3),
        flower: new Float32Array(PARTICLE_COUNT * 3),
        sphere: new Float32Array(PARTICLE_COUNT * 3),
        burst: new Float32Array(PARTICLE_COUNT * 3)
    };

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        // Heart
        const t = Math.random() * Math.PI * 2;
        data.heart[i3] = 16 * Math.pow(Math.sin(t), 3);
        data.heart[i3+1] = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        data.heart[i3+2] = (Math.random() - 0.5) * 6;

        // Saturn
        if (i < PARTICLE_COUNT * 0.5) {
            const u = Math.random(), v = Math.random();
            const th = 2 * Math.PI * u, ph = Math.acos(2 * v - 1);
            data.saturn[i3] = 10 * Math.sin(ph) * Math.cos(th);
            data.saturn[i3+1] = 10 * Math.sin(ph) * Math.sin(th);
            data.saturn[i3+2] = 10 * Math.cos(ph);
        } else {
            const r = 16 + Math.random() * 6, a = Math.random() * Math.PI * 2;
            data.saturn[i3] = r * Math.cos(a);
            data.saturn[i3+1] = (Math.random() - 0.5) * 1.5;
            data.saturn[i3+2] = r * Math.sin(a);
        }

        // Buddha Silhouette
        const by = (Math.random() - 0.5) * 25;
        const bRad = (12 - Math.abs(by)) * (0.4 + Math.sin(by * 0.2 + 1.2) * 0.6);
        const bA = Math.random() * Math.PI * 2;
        data.buddha[i3] = bRad * Math.cos(bA);
        data.buddha[i3+1] = by - 5;
        data.buddha[i3+2] = bRad * Math.sin(bA) * 0.7;

        // Flower
        const p = Math.random() * Math.PI * 2, th = Math.random() * Math.PI * 2;
        const fr = 15 * Math.cos(5 * p);
        data.flower[i3] = fr * Math.cos(p) * Math.sin(th);
        data.flower[i3+1] = fr * Math.sin(p) * Math.sin(th);
        data.flower[i3+2] = fr * Math.cos(th) * 0.3;

        // Sphere
        const st = Math.random() * Math.PI * 2, sp = Math.acos(2 * Math.random() - 1);
        data.sphere[i3] = 15 * Math.sin(sp) * Math.cos(st);
        data.sphere[i3+1] = 15 * Math.sin(sp) * Math.sin(st);
        data.sphere[i3+2] = 15 * Math.cos(sp);

        // Burst
        const br = Math.random() * 30, bt = Math.random() * Math.PI * 2, bp = Math.random() * Math.PI;
        data.burst[i3] = br * Math.sin(bp) * Math.cos(bt);
        data.burst[i3+1] = br * Math.sin(bp) * Math.sin(bt);
        data.burst[i3+2] = br * Math.cos(bp);
    }
    return data;
}

/**
 * INITIALIZATION
 */
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const geoData = createGeometries();
    Object.assign(shapes, geoData);

    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const colAttr = new Float32Array(PARTICLE_COUNT * 3);
    
    const baseColor = new THREE.Color(`hsl(${state.hue}, 70%, 60%)`);
    for(let i=0; i<PARTICLE_COUNT; i++) {
        colAttr[i*3] = baseColor.r; colAttr[i*3+1] = baseColor.g; colAttr[i*3+2] = baseColor.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('targetPosition', new THREE.BufferAttribute(shapes[state.shape], 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colAttr, 3));

    material = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uTransition: { value: 0 },
            uScale: { value: 1.0 },
            uSpread: { value: 1.0 },
            uNoise: { value: 1.2 },
            uPointSize: { value: 2.5 }
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    initTracking();
}

/**
 * HAND TRACKING ENGINE
 */
function initTracking() {
    video = document.getElementById('input_video');
    const canvasElement = document.getElementById('gesture_canvas');
    canvasCtx = canvasElement.getContext('2d');
    const indicator = document.getElementById('gesture-indicator');

    hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

    hands.onResults((res) => {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const hand = res.multiHandLandmarks[0];
            
            // 1. PINCH ROTATION (Z-Axis)
            const thumb = hand[4], index = hand[8];
            const pDist = Math.hypot(index.x - thumb.x, index.y - thumb.y);
            const pAngle = Math.atan2(index.y - thumb.y, index.x - thumb.x);
            
            if (pDist < 0.07) {
                state.isPinching = true;
                state.targetRot.z = pAngle + Math.PI/2;
                indicator.innerHTML = "<span class='text-indigo-400'>PINCH ACTIVE</span>";
            } else {
                state.isPinching = false;
                indicator.innerText = "Tracking Hand";
            }

            // 2. TILT (X/Y Axis)
            if (state.useTilt) {
                state.targetRot.y = (hand[9].x - 0.5) * 1.5;
                state.targetRot.x = (hand[9].y - 0.5) * 1.5;
            }

            // 3. SCALE (Finger Spread)
            const palmSize = Math.hypot(hand[0].x - hand[5].x, hand[0].y - hand[5].y);
            state.spread = THREE.MathUtils.mapLinear(pDist, 0.05, 0.3, 0.5, 2.5);
            
            // 4. DEPTH (Hand proximity)
            const depth = THREE.MathUtils.mapLinear(palmSize, 0.1, 0.4, 70, 20);
            state.zDepth = depth;

        } else {
            indicator.innerText = "No Hand Detected";
            state.isPinching = false;
        }
    });

    cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: 180, height: 135
    });
    
    cameraUtils.start().then(() => {
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => document.getElementById('loading').remove(), 800);
    });
}

/**
 * UI CALLBACKS
 */
function setShape(type) {
    state.shape = type;
    const target = particles.geometry.getAttribute('targetPosition');
    target.array.set(shapes[type]);
    target.needsUpdate = true;
    state.transition = 0;
    document.querySelectorAll('#shape-selector button').forEach(b => b.classList.toggle('active-btn', b.dataset.shape === type));
}

document.getElementById('hue-slider').addEventListener('input', (e) => {
    state.hue = e.target.value;
    document.getElementById('hue-val').innerText = state.hue;
    const colAttr = particles.geometry.getAttribute('color');
    const c = new THREE.Color(`hsl(${state.hue}, 70%, 60%)`);
    for(let i=0; i<PARTICLE_COUNT; i++) { colAttr.array[i*3]=c.r; colAttr.array[i*3+1]=c.g; colAttr.array[i*3+2]=c.b; }
    colAttr.needsUpdate = true;
});

document.getElementById('size-slider').addEventListener('input', (e) => {
    state.size = parseFloat(e.target.value);
    document.getElementById('size-val').innerText = state.size.toFixed(1);
});

document.getElementById('rotate-slider').addEventListener('input', (e) => {
    state.orbitSpeed = parseFloat(e.target.value) * 0.002;
    document.getElementById('rotate-val').innerText = e.target.value;
});

document.getElementById('tilt-toggle').addEventListener('change', (e) => state.useTilt = e.target.checked);

function captureScreenshot() {
    renderer.render(scene, camera);
    const link = document.createElement('a');
    link.download = 'aura-art.png';
    link.href = renderer.domElement.toDataURL('image/png');
    link.click();
}

/**
 * LOOP
 */
function animate(time) {
    requestAnimationFrame(animate);
    
    material.uniforms.uTime.value = time * 0.001;
    if (state.transition < 1.0) state.transition += 0.025;
    material.uniforms.uTransition.value = state.transition;
    
    material.uniforms.uSpread.value = THREE.MathUtils.lerp(material.uniforms.uSpread.value, state.spread, 0.1);
    material.uniforms.uPointSize.value = state.size + (state.isPinching ? 1.5 : 0);
    material.uniforms.uNoise.value = state.noise;

    // Movement Physics
    camera.position.z = THREE.MathUtils.lerp(camera.position.z, state.zDepth, 0.05);

    if (state.useTilt) {
        particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, state.targetRot.x, 0.08);
        particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, state.targetRot.y, 0.08);
        particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, state.targetRot.z, 0.1);
    } else {
        particles.rotation.y += state.orbitSpeed;
        particles.rotation.z += state.orbitSpeed * 0.5;
    }

    renderer.render(scene, camera);
}

init();
animate();

</script>
</body>
</html>